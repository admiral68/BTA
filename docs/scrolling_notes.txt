            HORIZONTAL SCROLLING-RIGHT; 4 BITPLANES
            DEST (SCREEN) BITMAP= 16+320(visible)+16 = 352px
            SOURCE BITMAP       = 2048px

            SRC:          DEST:  (BITPLANE PTR OFFSETS)   SRC         DEST      X-POS (PIXELS)
            -----------------------------------------     -----------------------------------------
PIXELS
SCROLLED  1      $B0      $2C                              $160         $0
          2    $10B0     $2EC                              $960       $160
          3    $20B0     $5AC                             $1160       $2C0
          4    $30B0     $86C                             $1960       $420
          5    $40B0     $B2C                             $2160       $580
          6    $50B0     $DEC                             $2960       $6E0
          7    $60B0    $10AC                             $3160       $840
          8    $70B0    $136C                             $3960       $9A0
          9    $80B0    $162C                             $4160       $B00
          A    $90B0    $18EC                             $4960       $C60
          B    $A0B0    $1BAC                             $5160       $DC0
          C    $B0B0    $1E6C                             $5960       $F20
          D    $C0B0    $212C                             $6160      $1080
          E    $D0B0    $23EC                             $6960      $11E0
          F    $E0B0    $26AC                             $7160      $1340














the bitmap is no longer double-wide. For 1x and 2x FETCH Modes an EXTRAWIDTH of 32 (2 * BLOCKWIDTH)

BITMAPWIDTH = 352
MAPWIDTH = 128
BITMAPBLOCKSPERROW = 352 / 16 = 22

overallbitmapheight = BITMAPHEIGHT + (MAPWIDTH : BITMAPBLOCKSPERROW : NUMPLANES) + 1
overallbitmapheight = 256 + (128 / 22 / 4) + 1 = 258

BITMAPHEIGHT is the actually wanted bitmap height, in our case 256 pixels.
MAPWIDTH is the width of the map in blocks.
BITMAPBLOCKSPERROW equals BITMAPWIDTH / BLOCKWIDTH, that is 22 (1x and 2x FETCH Mode) or 24 (4x FETCH Mode) in our case.


256 + (128 / 22 / 1) + 1 = 258





To calculate which block to blit in a certain situation (= map position) we devide the map position X by 16
and look at the remainder. The remainder determines the step. In C it is possible to calculate the remainder of a division
with the modulo operator (%). But since 16 is a power of 2 it can also be done with a binary AND:

1) MapPositionX % BLOCKWIDTH            0-127 % 16
2) MapPositionX & (BLOCKWIDTH - 1)

The result will be values between 0 and BLOCKWIDTH - 1.
In our case (that is a block width of 16 pixels) values between 0 and 15.
The block at the very top of the column is block 0,
the block at the very bottom is block 15. We wanted to scroll right, that is go from map position X 0 to map position X 1.
For a map position of 1 above calculation would give as a result of 1, but since we must or want to blit the topmost block (0)
first we increase the variable MapPositionX (in the source code called mapposx) only at the end of the ScrollRight() function.
By doing so when scrolling from map position 0 to map position 1 the calculation's result is step 0, for map position 1 to
map position 2 the calculation's result is step 1 etc. So the block column gets filled step by step with the new map area.

The X position of the fillup-column in the bitmap is the same as in Scroller_XUnlimited algorithm. We take the position
of the actual-bitmap-area (red rectangle) and round it down to a multiple of a block's width:

videoposx & ~(BLOCKWIDTH - 1)



 If for example we have a coordinate pair (x=0,y=1) where y is in planelines (1 pixelline consists of NUMPLANES planelines)
 then another coordinate pair (x=352,y=0) is equivalent, if we assume a bitmap width of 352 pixels.

BITMAPWIDTH=352
(x=352,y=0) = (x=0,y=1)

(MIND=BLOWN)

 Since the area is plane-shifted, blitting also needs to happen plane-shifted, that is the real destination Y
 coordinate of the single blocks we have to blit, needs to be increased by 1 planeline. The easiest way to do this,
 is to add BITMAPWIDTH (352) to the destination X (X not Y!) coordinate. By doing so we don't need to take extra
 care of the y positions. We simply can assume, that the fillup-column always starts at y position 0.




  SCROLL_LEFT:

   /* Restoring */

   if (Previous_ScrollDirection == RIGHT)
   {
       copy saveword to savewordpointer;
   }

   /* Backup */

   savewordpointer = address of the first planeline that will be overblitted
   saveword = content of savewordpointer

   /* Blit */

   Blit block

   Previous_ScrollDirection = LEFT

   return



 SCROLL_RIGHT:

   /* Restoring */

   if (Previous_ScrollDirection == LEFT)
   {
       copy saveword to savewordpointer
   }

   /* Backup */

   savewordpointer = address of the last planeline that will be overblitted
   saveword = content of savewordpointer

   /* Blit */

   Blit block

   Previous_ScrollDirection = RIGHT

   return





One question is still up. At which X position stays the fillup-column in the bitmap - where do we have to blit the new blocks?
Answer: At the place where the "going out" block column is. In the above example this would be column 0. Since during
scrolling each block is blitted twice, that is one time in the left bitmap half and one time in the right bitmap half,
the actual visible area when scrolling right slowly approaches the fillup-column of the right bitmap half. This column
will be completely done (filled = blitted) just in time before it becomes visible to the user. When this happens the
fillup-column will already have advanced one block to the right. In the source code the variable videoposx contains
the position of the actual-bitmap-area (red rectangle). We use this variable to calculate the position of the
fillup-column in the bitmap, that is the position where to blit the blocks. Again there is a slow (1) and a faster (2)
method - the latter only working if BLOCKWIDTH is a power of 2:

1) x = videoposx - (videoposx % BLOCKWIDTH)
2) x = videoposx & ~(BLOCKWIDTH - 1)

This formula calculates the position for the left bitmap half. For blitting into the right bitmap half we simply add
HALFBITMAPWIDTH, that is 352.
Scrolling to the left is pretty much the same except that we adjust the MapPositionX variable no longer at the
end of the scroll function but at the init. We use predecrement instead of postincrement as used in the scroll right
function, so to speak. The reason: Let's imagine to have scrolled from map position 0 to map position 1, that is 1
pixel to the right. The result is, that block 0 (at the very top) of the fillup-column is a block which came in at
the right side, more precisely block (22,0), that is the 23rd block of the topmost row in the map - in the following
picture shown as a yellow rectangle with a red outline:


#define ARG_SPEED 0
#define ARG_NTSC  1
#define ARG_HOW   2
#define ARG_SKY   3
#define ARG_FMODE 4
#define NUM_ARGS  5
#define mycustombase ((struct Custom *)0xdff000)
#define custom mycustombase

#define BPL0_USEBPLCON3_F  0x1
#define BPL0_COLOR_F       0x200
#define BPL0_BPU0_F        0x1000
#define BPL0_BPU3_F        0x10
#define BPL0_BPUMASK            0x7000

struct FetchInfo
{
    WORD    ddfstart;
    WORD    ddfstop;
    WORD    modulooffset;
    WORD    bitmapoffset;
    WORD    scrollpixels;
} fetchinfo [] =
{
    {0x30,0xD0,2,0,16}, /* normal         */
    {0x28,0xC8,4,16,32},    /* BPL32          */
    {0x28,0xC8,4,16,32},    /* BPAGEM         */
    {0x18,0xB8,8,48,64} /* BPL32 + BPAGEM */
};

struct RawMap
{
    WORD    mapwidth;
    WORD    mapheight;
    WORD    maplayers;
    WORD    blockwidth;
    WORD    blockheight;
    BYTE    bytesperblock;
    BYTE    transparentblock;
    UBYTE   data[1];
};

    SECTION copperlist,DATA,CHIP

_CopperList:
    dc.w    $180,0

_CopFETCHMODE:
    dc.w    $1FC,0

_CopBPLCON0:
    dc.w    $100,0

_CopBPLCON1:
    dc.w    $102,0

_CopBPLCON3:
    dc.w    $106,0

_CopBPLMODA:
    dc.w    $108,0

_CopBPLMODB:
    dc.w    $10A,0

_CopDIWSTART:
    dc.w    $8e,0

_CopDIWSTOP:
    dc.w    $90,0

_CopDDFSTART:
    dc.w    $92,0

_CopDDFSTOP:
    dc.w    $94,0

_CopPLANE1H:
    dc.w    $e0,0

_CopPLANE1L:
    dc.w    $e2,0

_CopPLANE2H:
    dc.w    $e4,0

_CopPLANE2L:
    dc.w    $e6,0

_CopPLANE3H:
    dc.w    $e8,0

_CopPLANE3L:
    dc.w    $ea,0

_CopPLANE4H:
    dc.w    $ec,0

_CopPLANE4L:
    dc.w    $ee,0

_CopPLANE5H:
    dc.w    $f0,0

_CopPLANE5L:
    dc.w    $f2,0

_CopPLANE6H:
    dc.w    $f4,0

_CopPLANE6L:
    dc.w    $f6,0

_CopPLANE7H:
    dc.w    $f8,0

_CopPLANE7L:
    dc.w    $fa,0

_CopPLANE8H:
    dc.w    $fc,0

_CopPLANE8L:
    dc.w    $fe,0

_CopSKY:
    dc.w    -1,-2           ;ends copperlist, unless...
    dc.w    $180,$FFF

    dc.w    $390f,-2
    dc.w    $180,$EEF
    dc.w    $3A0f,-2
    dc.w    $180,$FFF
    dc.w    $3B0f,-2
    dc.w    $180,$EEF

    dc.w    $490f,-2
    dc.w    $180,$DDF
    dc.w    $4a0f,-2
    dc.w    $180,$EEF
    dc.w    $4b0f,-2
    dc.w    $180,$DDF

    dc.w    $590f,-2
    dc.w    $180,$CCF
    dc.w    $5A0f,-2
    dc.w    $180,$DDF
    dc.w    $5B0f,-2
    dc.w    $180,$CCF

    dc.w    $690f,-2
    dc.w    $180,$BBF
    dc.w    $6A0f,-2
    dc.w    $180,$CCF
    dc.w    $6B0f,-2
    dc.w    $180,$BBF

    dc.w    $790f,-2
    dc.w    $180,$AAF
    dc.w    $7A0f,-2
    dc.w    $180,$BBF
    dc.w    $7B0f,-2
    dc.w    $180,$AAF

    dc.w    $890f,-2
    dc.w    $180,$99E
    dc.w    $8A0f,-2
    dc.w    $180,$AAF
    dc.w    $8B0f,-2
    dc.w    $180,$99E

    dc.w    $990f,-2
    dc.w    $180,$88E
    dc.w    $9A0f,-2
    dc.w    $180,$99E
    dc.w    $9B0f,-2
    dc.w    $180,$88E

    dc.w    $A90f,-2
    dc.w    $180,$77E
    dc.w    $AA0f,-2
    dc.w    $180,$88E
    dc.w    $AB0f,-2
    dc.w    $180,$77E

    dc.w    $B90f,-2
    dc.w    $180,$66E
    dc.w    $BA0f,-2
    dc.w    $180,$77E
    dc.w    $BB0f,-2
    dc.w    $180,$66E

    dc.w    $C90f,-2
    dc.w    $180,$55D
    dc.w    $CA0f,-2
    dc.w    $180,$66E
    dc.w    $CB0f,-2
    dc.w    $180,$55D

    dc.w    $D90f,-2
    dc.w    $180,$44D
    dc.w    $DA0f,-2
    dc.w    $180,$55D
    dc.w    $DB0f,-2
    dc.w    $180,$44D

    dc.w    $E90f,-2
    dc.w    $180,$33D
    dc.w    $EA0f,-2
    dc.w    $180,$44D
    dc.w    $EB0f,-2
    dc.w    $180,$33D

    dc.w    $F90f,-2
    dc.w    $180,$22C
    dc.w    $FA0f,-2
    dc.w    $180,$33D
    dc.w    $FB0f,-2
    dc.w    $180,$22C

    dc.w    $FFDF,-2
    dc.w    $090F,-2
    dc.w    $180,$11C
    dc.w    $0A0F,-2
    dc.w    $180,$22C
    dc.w    $0B0F,-2
    dc.w    $180,$11C

    dc.w    $190f,-2
    dc.w    $180,$00B
    dc.w    $1A0f,-2
    dc.w    $180,$11C
    dc.w    $1B0f,-2
    dc.w    $180,$00B

    dc.w    -1,-2
    END


void main(void)
{
    GetArguments();
    OpenMap();
    AllocBitMap(BLOCKSWIDTH,BLOCKSHEIGHT,BLOCKSDEPTH,BMF_STANDARD | BMF_INTERLEAVED,0)
    l = BLOCKSWIDTH * BLOCKSHEIGHT * BLOCKSDEPTH / 8;
    bitmapheight = BITMAPHEIGHT + (mapwidth / BITMAPBLOCKSPERROW / BLOCKSDEPTH) + 1 + 3;
    AllocBitMap(BITMAPWIDTH,bitmapheight,BLOCKSDEPTH,BMF_STANDARD | BMF_INTERLEAVED | BMF_CLEAR,0));
    frontbuffer = ScreenBitmap->Planes[0];
    frontbuffer += (fetchinfo[option_fetchmode].bitmapoffset / 8);

    // InitCopperlist

    WaitVBL();

    custom->dmacon = 0x7FFF;
    custom->beamcon0 = option_ntsc ? 0 : DISPLAYPAL;

    CopFETCHMODE[1] = option_fetchmode;
    // bitplane control registers

    CopBPLCON0[1] = ((BLOCKSDEPTH * BPL0_BPU0_F) & BPL0_BPUMASK) +
                     ((BLOCKSDEPTH / 8) * BPL0_BPU3_F) +
                       BPL0_COLOR_F + (option_speed ? 0 : BPL0_USEBPLCON3_F);

    CopBPLCON1[1] = 0;
    CopBPLCON3[1] = BPLCON3_BRDNBLNK;

    // bitplane modulos

    l = BITMAPBYTESPERROW * BLOCKSDEPTH -
        SCREENBYTESPERROW - fetchinfo[option_fetchmode].modulooffset;

    CopBPLMODA[1] = l;
    CopBPLMODB[1] = l;

    // display window start/stop

    CopDIWSTART[1] = DIWSTART;
    CopDIWSTOP[1] = DIWSTOP;

    // display data fetch start/stop

    CopDDFSTART[1] = fetchinfo[option_fetchmode].ddfstart;
    CopDDFSTOP[1]  = fetchinfo[option_fetchmode].ddfstop;

    // plane pointers

    wp = CopPLANE1H;

    for(l = 0;l < BLOCKSDEPTH;l++)
    {
        wp[1] = (WORD)(((ULONG)ScreenBitmap->Planes[l]) >> 16);
        wp[3] = (WORD)(((ULONG)ScreenBitmap->Planes[l]) & 0xFFFF);

        wp += 4;
    }

    if (option_sky)
    {
        // activate copper sky

        CopSKY[0] = 0x290f;
    }

    custom->intena = 0x7FFF;

    custom->dmacon = DMAF_SETCLR | DMAF_BLITTER | DMAF_COPPER | DMAF_RASTER | DMAF_MASTER;

    custom->cop2lc = (ULONG)CopperList;

    // end copperlist

    WORD a,b,x,y;
    // fill screen
    for (b = 0;b < BITMAPBLOCKSPERCOL;b++)
    {
        for (a = 0;a < BITMAPBLOCKSPERROW;a++)
        {
            x = a * BLOCKWIDTH;
            y = b * BLOCKPLANELINES;
            DrawBlock(x,y,a,b);
        }
    }

    HardWaitBlit();
    WaitVBL();

    // activate copperlist
    custom->copjmp2 = 0;

    while (!LMBDown())
    {
        if (!option_how)
        {
            WaitVBeam(199);
            WaitVBeam(200);
        } else {
            Delay(1);
        }

        if (option_speed) *(WORD *)0xdff180 = 0xFF0;

        if (JoyFire()) count = 8; else count = 1;

        if (JoyLeft())
        {
            for(i = 0;i < count;i++)
            {
                WORD mapx,mapy,x,y;

                if (mapposx < 1) return;

                mapposx--;
                videoposx = mapposx;

                mapx = mapposx / BLOCKWIDTH;
                mapy = mapposx & (NUMSTEPS - 1);

                x = ROUND2BLOCKWIDTH(videoposx);
                y = mapy * BLOCKPLANELINES;

                if (previous_direction == DIRECTION_RIGHT)
                {
                    HardWaitBlit();
                    *savewordpointer = saveword;
                }

                savewordpointer = (WORD *)(frontbuffer + y * BITMAPBYTESPERROW + (x / 8));
                saveword = *savewordpointer;

                DrawBlock(x,y,mapx,mapy);

                previous_direction = DIRECTION_LEFT;
            }
        }

        if (JoyRight())
        {
            for(i = 0;i < count;i++)
            {
                WORD mapx,mapy,x,y;

                if (mapposx >= (mapwidth * BLOCKWIDTH - SCREENWIDTH - BLOCKWIDTH)) return;

                mapx = mapposx / BLOCKWIDTH + BITMAPBLOCKSPERROW;
                mapy = mapposx & (NUMSTEPS - 1);

                x = BITMAPWIDTH + ROUND2BLOCKWIDTH(videoposx);
                y = mapy * BLOCKPLANELINES;

                if (previous_direction == DIRECTION_LEFT)
                {
                    HardWaitBlit();
                    *savewordpointer = saveword;
                }

                savewordpointer = (WORD *)(frontbuffer + (y + BLOCKPLANELINES - 1) * BITMAPBYTESPERROW + (x / 8));
                saveword = *savewordpointer;

                DrawBlock(x,y,mapx,mapy);

                mapposx++;
                videoposx = mapposx;

                previous_direction = DIRECTION_RIGHT;
            }
        }

        if (option_speed) *(WORD *)0xdff180 = 0xF00;

        ULONG pl;
        WORD xpos,planeaddx,scroll,i;
        WORD *wp;

        i = fetchinfo[option_fetchmode].scrollpixels;

        xpos = videoposx + i - 1;

        planeaddx = (xpos / i) * (i / 8);
        i = (i - 1) - (xpos & (i - 1));

        scroll = (i & 15) * 0x11;
        if (i & 16) scroll |= (0x400 + 0x4000);
        if (i & 32) scroll |= (0x800 + 0x8000);

        // set scroll register in BPLCON1

        CopBPLCON1[1] = scroll;

        // set plane pointers

        wp = CopPLANE1H;

        for(i = 0;i < BLOCKSDEPTH;i++)
        {
            pl = ((ULONG)ScreenBitmap->Planes[i]) + planeaddx;

            wp[1] = (WORD)(pl >> 16);
            wp[3] = (WORD)(pl & 0xFFFF);

            wp += 4;
        }
    }
}

/******************* SCROLLING **********************/

static void DrawBlock(LONG x,LONG y,LONG mapx,LONG mapy)
{
    UBYTE block;

    // x = in pixels
    // y = in "planelines" (1 realline = BLOCKSDEPTH planelines)


    x = (x / 8) & 0xFFFE;
    y = y * BITMAPBYTESPERROW;

    block = mapdata[mapy * mapwidth + mapx];

    mapx = (block % BLOCKSPERROW) * (BLOCKWIDTH / 8);
    mapy = (block / BLOCKSPERROW) * (BLOCKPLANELINES * BLOCKSBYTESPERROW);

    HardWaitBlit();

    custom->bltcon0 = 0x9F0;    // use A and D. Op: D = A
    custom->bltcon1 = 0;
    custom->bltafwm = 0xFFFF;
    custom->bltalwm = 0xFFFF;
    custom->bltamod = BLOCKSBYTESPERROW - (BLOCKWIDTH / 8);
    custom->bltdmod = BITMAPBYTESPERROW - (BLOCKWIDTH / 8);
    custom->bltapt  = blocksbuffer + mapy + mapx;
    custom->bltdpt   = frontbuffer + y + x;

    custom->bltsize = BLOCKPLANELINES * 64 + (BLOCKWIDTH / 16);
}








.....................................................



HEROW       equ 16
HEROH       equ 22

ScrHeight:              ; ScrHeight before ScrWidth!
    ds.w    1
    xdef    ScrWidth
ScrWidth:
    ds.w    1

View:
    dc.l    View1,View2

    ; Double buffered View
View1:
    ds.b    sizeof_View
View2:
    ds.b    sizeof_View

; size of unmasked hero image in bytes
HEROSIZE    equ (HEROW>>3)*HEROH*PLANES


; maximum map dimensions
MAXMAPW     equ 256
MAXMAPH     equ 256

; extra lines at top and bottom of the map
MAPTOPEXTRA equ 4   ; hero can't jump over blocks on top of the map
MAPBOTEXTRA equ 2   ; two empty lines until hero left the map



    ; Space for the copper background definitions. The worst case is
    ; a changed color in each line (which shouldn't happen). As we
    ; scroll the background at half of the vertical scroll speed, the
    ; size would be half of the maximum map height * 16 pixels per block.
    ; WARNING: the minimum height of a copper background should be
    ; the maximum map height in pixels / 2 + DISPH / 2.
Copperbars:
    ds.l    MAXMAPH*16/2



; -> d0 = StartX = 0
; -> d1 = StartY = 0

; Set the map position of the top-left display edge.
; Warning: Needs to be followed by copper_scroll() and draw_tiles(),
; which redraws the whole bitmap. scroll() is for small movements only!
; d0 = xpos.w
; d1 = ypos.w

    move.l  d2,a0
    moveq   #0,d2
    move.w  d1,d2
    divu    #BMAPH,d2           ;((DISPH/16)+EXTRAROWS)*16  19*16  304
            d2 = 0
    swap    d2
    movem.w d0-d2,Xpos(a4)      ; initialize Xpos, Ypos, Ymod
    move.l  a0,d2

    ; determine our position on the copper background
    move.l  CopperbarTab(a4),a1                             (256*16/2)
    subq.l  #4,a1
    asr.w   #1,d1
    move.w  d1,CbackPos(a4)
.1: addq.l  #4,a1
    move.w  (a1),d0
    sub.w   d0,d1
    bpl .1
    move.l  a1,CbackPtr(a4)
    add.w   d0,d1
    move.w  d1,CbackOffs(a4)



scroll:
; Scroll the View to match the current MapX/MapY coordinates.
; a5 = View
; Registers, except a4 - a6, are not preserved!




; Change BPLPTx and BPLCON1 to view the requested position.
; a5 = View
; -> d2 = xpos
; -> d3 = ypos
; -> d4 = ypos % BMAPH   (304)
; Registers, except a4 - a6, are not preserved!

    movem.w Xpos(a4),d2-d4
    move.l  Vclist(a5),a2

    ; write fine scrolling code for (xpos & 15)
    moveq   #15,d0
    and.w   d2,d0
    add.w   d0,d0
    move.w  ScrollTab(pc,d0.w),Cl_scroll+2(a2)

    ; calculate xoffset on bitplanes
    move.l  Vbitmap(a5),a0
    move.w  d2,d0
    subq.w  #1,d0           ; prefetch, when xpos&15 is 0
    and.w   #$fff0,d0
    asr.w   #3,d0
    add.w   d0,a0

    ; calculate a second bitplane pointer with xoffset and ymodulo
    lea YOffTab(a4),a1
    move.w  d4,d0
    add.w   d0,d0
    add.w   d0,d0
    move.l  (a1,d0.w),d6
    add.l   a0,d6           ; d6 (top): bitmap + xoffset + ymodulo
    move.l  a0,d7           ; d7 (split): bitmap + xoffset

    ; determine real Vtop and Vsplit bitmap pointer for rendering
    move.l  d6,a0
    move.l  d7,a1
    moveq   #15,d0
    and.w   d2,d0
    bne .1
    addq.l  #2,a0
    addq.l  #2,a1
.1: movem.l a0-a1,Vtop(a5)

    ; calculate current y-offset of split
    move.w  #BMAPH,d1
    sub.w   d4,d1
    move.w  d1,Vsplyoff(a5)

    ; calculate raster line of display split
    IFND    COPPERBACK
    move.w  #VEND,d0
    ELSE
    move.l  #DISPH,d0
    ENDIF
    moveq   #-EXTRAROWS*16,d1
    add.w   d4,d1
    bmi .2          ; no split
    sub.w   d1,d0

    IFND    COPPERBACK
    ; write WAIT command for split line
.2: move.b  d0,Cl_waitsplit+4(a2)
    and.w   #$ff00,d0
    sne Cl_waitsplit(a2)

    ; write updated bitplane pointers for top and split section
    lea Cl_bpltop+2(a2),a0
    moveq   #PLANES-1,d0
    move.w  #BPR,a1
.3: swap    d6
    move.w  d6,(a0)
    swap    d6
    move.w  d6,4(a0)
    swap    d7
    move.w  d7,Cl_bplsplit-Cl_bpltop(a0)
    swap    d7
    move.w  d7,4+Cl_bplsplit-Cl_bpltop(a0)
    addq.l  #8,a0
    add.l   a1,d6
    add.l   a1,d7
    dbf d0,.3
    rts

    ELSE    ; COPPERBACK

.2: move.w  #BPR,a1         ; a1 = BPR

    ; write updated bitplane pointers for the top of the display
    lea Cl_bpltop+2(a2),a0
    moveq   #PLANES-1,d1
.3: swap    d6
    move.w  d6,(a0)
    swap    d6
    move.w  d6,4(a0)
    addq.l  #8,a0
    add.l   a1,d6
    dbf d1,.3

    ; determine current top background copper bar and its height
    move.l  CbackPtr(a4),a3
    move.w  CbackOffs(a4),d2
    asr.w   #1,d3           ; new position on copper background
    move.w  CbackPos(a4),d1     ; old position
    move.w  d3,CbackPos(a4)
    sub.w   d1,d3           ; y-delta on background
    beq .copperback_init    ; no change
    bpl .6
    bra .5

    ; scrolling upwards (smaller y), find new copper bar position
.4: subq.l  #4,a3
    move.w  (a3),d3
.5: add.w   d3,d2
    bmi .4
    bra .8

    ; scrolling downwards (greater y), find new copper bar position
.6: neg.w   d3
    subq.l  #4,a3
.7: addq.l  #4,a3
    sub.w   d3,d2
    move.w  (a3),d3
    cmp.w   d3,d2
    bhs .7

    ; update position in the copper bar table
.8: move.l  a3,CbackPtr(a4)
    move.w  d2,CbackOffs(a4)

.copperback_init:
    moveq   #0,d1
    move.w  (a3)+,d1
    sub.w   d2,d1           ; remaining height of first copper bar

    lea Cl_colors(a2),a2
    movem.l .copperback_reginit(pc),d2-d4
    move.w  #$ffdf,d5
    bra .writeinstr

.copperback_reginit:
    dc.l    (VSTART-1)<<24|$df<<16|$fffe
    dc.l    COLOR01<<16
    dc.l    BPL1PTH<<16|DISPH-1

.copperback_loop:
    moveq   #0,d1
    move.w  (a3)+,d1        ; height of this copper bar

.writeinstr:
    move.l  d2,(a2)+        ; WAIT
    move.w  (a3)+,d3        ; get new color
    move.l  d3,(a2)+        ; COLOR01

    ; check whether this bar includes the split line
    sub.w   d1,d0
    blo .split_bplpt

    ; check whether this bar passes or extends until VPOS=$100
.addheight:
    sub.w   d1,d4
    ror.l   #8,d1
    add.l   d1,d2
    bcs .vposoverflow

    ; loop until all lines of the display got a color
    tst.w   d4
    bpl .copperback_loop

    moveq   #-2,d0
    move.l  d0,(a2)         ; end of copper list
    movem.w Xpos(a4),d2-d4
    rts


.vposoverflow:
    ; Next WAIT is on or after raster line $100. This means that
    ; we have to insert a WAIT for end of line $ff, when not
    ; already done.
    ; a2 = copper list pointer
    ; d2 = last WAIT
    ; d5.w = $ffdf

    cmp.w   -8(a2),d5
    beq .copperback_loop    ; last WAIT was already for VPOS=$ff
    move.w  d5,(a2)+
    move.w  d2,(a2)+
    bra .copperback_loop


.split_bplpt:
    ; Write bitplane pointers for the split section. At this line
    ; the pointers are reset to point to the top of the bitmap.
    ; This might happen within a copper bar and the bar might also
    ; pass over raster line $100. Handle all these cases!
    ; a2 = copper list pointer
    ; d0 = height of copper bar after the split line (negated value)
    ; d1 = height of copper bar
    ; d2 = last WAIT
    ; d4 = remaining display lines
    ; d5.w = $ffdf
    ; d7 = top bitmap pointers

    add.w   d1,d0           ; split line offset into copper bar
    beq .write_split        ; same line as last WAIT

    ; set remaining height of copper bar after the split
    sub.w   d0,d1
    sub.w   d0,d4

    ; split is not at the top of a copper bar, so insert another WAIT
    ror.l   #8,d0
    add.l   d0,d2
    bcc .splitwait

    ; wait for line $ff first, when passing line $100
    cmp.w   -8(a2),d5
    beq .splitwait      ; last WAIT was already for VPOS=$ff
    move.w  d5,(a2)+
    move.w  d2,(a2)+

.splitwait:
    move.l  d2,(a2)+        ; wait for split line

    ; write updated bitplane pointers for the split section
.write_split:
    swap    d4          ; BPL1PTH to LSW
    moveq   #PLANES-1,d0
.split_loop:
    move.w  d4,(a2)+
    swap    d7
    move.w  d7,(a2)+
    addq.w  #2,d4
    move.w  d4,(a2)+
    swap    d7
    move.w  d7,(a2)+
    addq.w  #2,d4
    add.l   a1,d7
    dbf d0,.split_loop
    swap    d4          ; get remaining height back into LSW
    bra .addheight

    ENDIF   ; COPPERBACK


    ; Load/update View position
    movem.w Vxpos(a5),d0-d1
    movem.w d2-d3,Vxpos(a5)

//blitter_scroll

; Draw new blocks in the border when required.
; a5 = View
; d0 = oldxpos
; d1 = oldypos
; d2 = newxpos
; d3 = newypos
; d4 = newypos % BMAPH
; Registers, except a4 - a6, are not preserved!

    ; convert xpos/ypos into tile-columns/rows
    asr.w   #4,d0
    asr.w   #4,d1
    asr.w   #4,d2
    asr.w   #4,d3

    ; check if a new column was entered
    cmp.w   d0,d2
    beq .check_dy
    bgt .pos_dx

    ; Negative delta-x.
    ; Remember the last column being deleted by left-scrolling in Vdelcol.
    ; We must not draw it as the rightmost tile in a new row.
    ; Remove all DrawNodes from the deleted column.
    ; Set Vmapcol to the new column to blit at the left side.
    moveq   #XBLOCKS-2,d0
    add.w   d2,d0
    move.w  d0,Vdelcol(a5)
    bsr del_drawnode_x

    moveq   #-1,d0
    add.w   d2,d0           ; column from map to blit
    bmi .check_dy

    move.w  d0,Vmapcol(a5)
    move.w  #BLTPHASES*2,Vcolcnt(a5)
    bra .check_dy

    ; Positive delta-x.
    ; Disable Vdelcol.
    ; Remove all DrawNodes from the deleted column.
    ; Set Vmapcol to the new column to blit at the right side.
.pos_dx:
    moveq   #-2,d0
    move.w  d0,Vdelcol(a5)      ; disabled Vdelcol check
    add.w   d2,d0
    bsr del_drawnode_x

    moveq   #XBLOCKS-3,d0
    add.w   d2,d0           ; column from map to blit
    cmp.w   MapWidth(a4),d0
    bge .check_dy

    move.w  d0,Vmapcol(a5)
    move.w  #BLTPHASES*2,Vcolcnt(a5)

.check_dy:
; d1 = old row
; d2 = new column
; d3 = new row
; d4 = newypos % BMAPH

    ; check if a new row was entered
    cmp.w   d1,d3
    beq .work
    bgt .pos_dy

    ; Negative delta-y.
    ; Remember the last row being deleted by up-scrolling in Vdelrow.
    ; We must not draw it as the bottommost tile in a new column.
    ; Remove all DrawNodes from the deleted row.
    moveq   #YBLOCKS-1,d0
    add.w   d3,d0
    move.w  d0,Vdelrow(a5)
    bsr del_drawnode_y

    subq.w  #1,d3           ; row from map to blit
    bmi .work

    asr.w   #4,d4
    subq.w  #1,d4           ; row on bitmap to update
    bpl .setyblt
    add.w   #YBLOCKS,d4
    bra .setyblt

    ; Positive delta-y.
    ; Disable Vdelrow.
    ; Remove all DrawNodes from the deleted row.
.pos_dy:
    moveq   #-2,d0
    move.w  d0,Vdelrow(a5)
    add.w   d3,d0
    bsr del_drawnode_y

    moveq   #YBLOCKS-2,d0
    add.w   d0,d3           ; row from map to blit
    cmp.w   MapHeight(a4),d3
    bge .work

    asr.w   #4,d4
    add.w   d0,d4           ; row on bitmap to update
    cmp.w   #YBLOCKS,d4
    blt .setyblt
    sub.w   #YBLOCKS,d4

    ; Vrowcol = first column of the new row
    ; Vmaprow = new row from the map
    ; Vbufrow = row on the bitmap to update
.setyblt:
    subq.w  #1,d2           ; column-offset for this row
    move.w  d2,Vrowcol(a5)
    move.w  d3,Vmaprow(a5)
    move.w  d4,Vbufrow(a5)
    move.w  #BLTPHASES*2,Vrowcnt(a5)
    add.w   d4,d4
    move.w  d3,Vvisrows(a5,d4.w)    ; new visible map row on the bitmap

    ;-------------------------------------------------------------
    ; Blit tiles of a new row or column, when there is work to do
    ;-------------------------------------------------------------
.work:
    ; load needed pointers
    lea Tiles(a4),a1
    lea MapRowOffTab(a4),a2
    lea RowOffTab(a4),a3
    move.l  Vlastdn(a5),d3
    move.l  FgMap(a4),d4
    move.l  Map(a4),d5

    ; save small-data base - no static data is available in this section!
    move.l  a4,-(sp)

    ; are there any new column tiles left to blit?
    move.w  Vcolcnt(a5),d7
    bne .workcol
    bra .chkrowcnt

.tileYPos:  ; ypos to start drawing for each phase
    TILEYPOS
.tileYCnt:  ; number of tiles to draw (-1) in each phase
    TILEYCNT

    ;---------------------------------
    ; draw some tiles of a new column
    ;---------------------------------
.workcol:
    subq.w  #2,d7
    move.w  d7,Vcolcnt(a5)

    moveq   #0,d2
    move.w  Vmapcol(a5),d2      ; column to blit
    move.w  .tileYPos(pc,d7.w),d6
    move.w  .tileYCnt(pc,d7.w),d7

    ; calculate destination bitmap pointer for first tile to blit
    move.w  d6,d0
    move.l  Vbitmap(a5),a4
    add.w   d0,d0
    add.l   (a3,d0.w),a4        ; add bitmap row-offset
    add.w   d2,a4
    add.w   d2,a4           ; and add col-offset (col is 2 bytes)

    ; preconfigure Blitter: copy D=A, AMOD=0, DMOD=BPR-2
    moveq   #-1,d1
    WAITBLIT
    move.l  d1,BLTAFWM(a6)
    move.l  #0<<16|BPR-2,BLTAMOD(a6)
    move.l  #$09f00000,BLTCON0(a6)

.col_loop:
    ; get the corresponding map row for a specific row on the display
    move.w  Vvisrows(a5,d6.w),d0
    cmp.w   Vdelrow(a5),d0
    beq .col_nextrow        ; tile is already obsolete, skip it
    add.w   d0,d0
    add.w   d0,d0
    move.l  (a2,d0.w),d1
    add.l   d2,d1           ; map-offset for current column/row

    ; check for a new foreground block to draw
    move.l  d4,a0
    moveq   #0,d0
    move.b  (a0,d1.l),d0        ; block number from foreground map
    beq .col_draw       ; no fg block, just draw the new tile

    ; enter new foreground block into the DrawList
    exg d3,a4
    move.l  DNnext(a4),a4
    tst.l   DNnext(a4)
    beq .col_overfl     ; DrawList overflowed! No more nodes.

    ; initialize new DrawNode
    lea DNcol(a4),a0
    move.w  d2,(a0)+        ; DNcol
    move.w  Vvisrows(a5,d6.w),(a0)+ ; DNrow
    move.l  d1,d0
    add.l   d5,d0           ; Map-pointer
    move.l  d0,(a0)+        ; DNbmap
    add.l   d4,d1           ; FgMap-pointer
    move.l  d1,(a0)+        ; DNfmap
    move.l  d3,(a0)         ; DNpos - bitmap pointer
    exg d3,a4
    bra .col_nextrow        ; no need to draw the tile now

.col_overfl:
    ifd DEBUG
    trap    #5          ; DrawList is too small
    endif
    move.l  DNprev(a4),a4
    exg d3,a4

.col_draw:
    ; calculate address of tile image
    move.l  d5,a0
    moveq   #0,d0
    move.b  (a0,d1.l),d0        ; tile number from map
    add.w   d0,d0
    add.w   d0,d0
    move.l  (a1,d0.w),d1

    ; blit next tile
    WAITBLIT
    move.l  d1,BLTAPT(a6)
    move.l  a4,BLTDPT(a6)
    move.w  #(16*PLANES)<<6|1,BLTSIZE(a6)

.col_nextrow:
    addq.w  #2,d6
    lea 16*PLANES*BPR(a4),a4
    dbf d7,.col_loop

.chkrowcnt:
    ; are there any new row tiles left to blit?
    move.w  Vrowcnt(a5),d7
    beq .done
    bra .workrow

.tileXOff:  ; x-offset in columns to start drawing for each phase
    TILEXOFF
.tileXCnt:  ; number of tiles to draw (-1) in each phase
    TILEXCNT

    ;------------------------------
    ; draw some tiles of a new row
    ;------------------------------
.workrow:
    subq.w  #2,d7
    move.w  d7,Vrowcnt(a5)

    ; calculate destination bitmap pointer for first tile to blit
    move.l  Vbitmap(a5),a4
    move.w  Vrowcol(a5),d1      ; start column of this row
    add.w   d1,a4
    add.w   d1,a4           ; add byte-offset of start-column
    move.w  .tileXOff(pc,d7.w),d2
    add.w   d2,a4
    add.w   d2,a4           ; add byte-offset of phase
    move.w  Vbufrow(a5),d0
    add.w   d0,d0
    add.w   d0,d0
    add.l   (a3,d0.w),a4        ; add bitmap row-offset

    ; calculate map pointer to first tile
    move.l  d4,a3
    move.w  Vmaprow(a5),d0
    move.w  d0,d4           ; d4 row
    add.w   d0,d0
    add.w   d0,d0
    move.l  (a2,d0.w),a0        ; row-offset
    add.w   d1,d2           ; d2 row start-col + phase col-offset
    add.w   d2,a0           ; map-offset
    add.l   a0,a3           ; a3 foreground map pointer
    add.l   d5,a0           ; a0 background map pointer

    ; get number of tiles to blit - 1
    move.w  .tileXCnt(pc,d7.w),d7

    ; The rightmost tile of the new row might become obsolete when
    ; scrolling diagonally to the left. The last tile col calculates as:
    ; row start-col + phase col-offset + tiles to blit - 1 (d2 + d7)
    ; Do not draw it and especially do not create DrawNodes for
    ; foreground blocks, when it was just deleted (column matches Vdelcol).
    move.w  d2,d0
    add.w   d7,d0
    cmp.w   Vdelcol(a5),d0
    bne .rowpreconf
    subq.w  #1,d7           ; ignore the rightmost tile

.rowpreconf:
    ; preconfigure Blitter: copy D=A, AMOD=0, DMOD=BPR-2
    moveq   #-1,d1
    WAITBLIT
    move.l  d1,BLTAFWM(a6)
    move.l  #0<<16|BPR-2,BLTAMOD(a6)
    move.l  #$09f00000,BLTCON0(a6)

    move.l  d3,a2           ; last DrawNode

.row_loop:
    ; check for a new foreground block to draw
    moveq   #0,d0
    move.b  (a3),d0         ; block number from foreground map
    beq .row_draw       ; no fg block, just draw the new tile

    ; enter new foreground block into the DrawList
    move.l  DNnext(a2),a2
    tst.l   DNnext(a2)
    beq .row_overfl     ; DrawList overflowed! No more nodes.

    ; initialize new DrawNode
    move.l  a0,d1
    lea DNcol(a2),a0
    move.w  d2,(a0)+        ; DNcol
    move.w  d4,(a0)+        ; DNrow
    move.l  d1,(a0)+        ; DNbmap
    move.l  a3,(a0)+        ; DNfmap
    move.l  a4,(a0)         ; DNpos - bitmap pointer
    move.l  d1,a0
    addq.l  #1,a0
    bra .row_nextcol        ; no need to draw the tile now

.row_overfl:
    ifd DEBUG
    trap    #5          ; DrawList is too small
    endif
    move.l  DNprev(a2),a2

.row_draw:
    ; calculate address of tile image
    move.b  (a0)+,d0        ; next tile in row
    add.w   d0,d0
    add.w   d0,d0
    move.l  (a1,d0.w),d1        ; address of tile image

    ; blit next tile
    WAITBLIT
    move.l  d1,BLTAPT(a6)
    move.l  a4,BLTDPT(a6)
    move.w  #(16*PLANES)<<6|1,BLTSIZE(a6)

.row_nextcol:
    addq.l  #1,a3
    addq.l  #2,a4
    addq.w  #1,d2
    dbf d7,.row_loop

    move.l  a2,d3

.done:
    ; restore small data base
    move.l  (sp)+,a4

    ; update last DrawNode
    move.l  d3,Vlastdn(a5)






    bsr reset_view
    move.l  View+4(a4),a5
    bsr reset_view

    ; make our sprites visible and redraw the score
    bsr activate_gamesprites
    move.l  Score(a4),d0
    bsr update_gamesprites

    movem.l (sp)+,d2/a5
    rts


my crap code


;   lea MapXYPosition,a1
;   lea VideoXYPosition,a2
;
;   REPT 16
;   bsr TESTGetXYPositionsForScrollRight
;   addi.l #16,(a1)
;   addi.l #16,(a2)
;   ENDR

;   move.l #$10F,d3
;   move.l #$250,d4
;
;   clr.l d1
;   clr.l d2
;
;   lea Screen,a5                                            ;frontbuffer
;   move.l a5,d2
;   move.w d4,d1                                             ;x
;   asr.w #3,d1                                              ;(x / 8)
;   add.l d1,d2                                              ;frontbuffer + (x / 8)
;
;   clr.l d1
;
;   swap d4                                                  ;y
;   move.w d4,d1
;   add.w #tile_plane_lines-1,d1                             ;(y + tile_plane_lines - 1)
;   mulu #(screen_width+screen_extrawidth)/2,d1              ;* bitmap_bytes_per_row
;   add.l d1,d2

